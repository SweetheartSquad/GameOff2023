::start
<<if !this.started>>
<<do
	// add `this.gotod(passage, delay)`
	this.gotoo = this.goto;
	this.goto = (passage) => {
		window.clearTimeout(this.auto);
		this.auto = 0;
		return this.gotoo(passage);
	};
	this.gotod = (passage, delay) => {
		window.clearTimeout(this.auto);
		this.auto = window.setTimeout(() => {
			this.goto(passage);
		}, delay);
	};

	// middle mouse click to go back in debug
	if (this.debug && !window.debugBack) {
		window.debugBack = true;
		window.addEventListener('pointerdown', (event) => {
			if (event.button === 1) {
				window.scene.strand.back();
			}
		});
	}

	// start with music off in debug
	// camera
	this.cameraPlaceholder = this.Model('camera_test');
	this.cameraPlaceholder.visible = false;

	const cameraPlaceholder = this.cameraPlaceholder.model.getChildByName('Camera');
	this.scene.camera3d.position = cameraPlaceholder.position;
	const camProps = window.resource('camera_test').descriptor.cameras[0].perspective;
	this.scene.camera3d.fieldOfView = camProps.yfov / Math.PI * 180;
	this.scene.camera3d.near = camProps.znear;
	this.scene.camera3d.far = camProps.zfar;

	// road + sway
	this.roadSpeed = 2;
	const roadSize = 100;
	this.roadAngle = 20; // degrees

	const baseDepth = 85;

	const roadSegments = Math.max(3, Math.ceil(this.scene.camera3d.far*2 / roadSize));

	this.roadAngle = this.roadAngle / 180 * Math.PI;
	const objs = this.Container3D();

	this.top = this.Model('top', 'palette', { depth: baseDepth });
	this.top.model.visible = false;
	this.bottom = this.Model('bottom', 'palette', { depth: baseDepth });
	this.bottom.model.visible = false;

	for(let i = 0; i < roadSegments; ++i) {
		const road = this.Model('groundPlane_3_20', 'palette', { depth: baseDepth });
		if (i === 0) {
			this.rootRoad = road;
		} else {
			this.rootRoad.model.addChild(road.model);
		}
		road.model.position.z = -i * roadSize * Math.cos(this.roadAngle);
		road.model.position.y = i * roadSize * Math.sin(this.roadAngle);


		const forest = this.Model('forest', 'palette', { depth: baseDepth });
		road.model.addChild(forest.model);
		const forest2 = this.Model('forest2', 'palette', { depth: baseDepth });
		road.model.addChild(forest2.model);
		const rocks1 = this.Model('rocks1', 'palette', { depth: baseDepth });
		road.model.addChild(rocks1.model);
	}
	const xRoot = this.rootRoad.model.position.x;
	const yRoot = this.rootRoad.model.position.y;
	let curPos = 0;
	let roadDelta = 0;
	let rootY = this.scene.camera3d.position.y;
	this.stepping = 0;
	this.Updater(() => {
		objs.container.children.forEach(i => {
			if (i.loops >= 2) {
				this.destroy(i.gameObject);
			}
		});
	});
	this.Updater(() => {
		roadDelta = game.app.ticker.deltaMS / 1000 * this.roadSpeed * this.ease.cubicInOut(this.stepping);
		this.scene.camera3d.position.y = rootY + (1-this.ease.cubicInOut(Math.abs(0.5-this.ease.cubicInOut(this.stepping))*2))*0.01;
		curPos += roadDelta;
		let oldz = objs.container.position.z;
		let oldy = objs.container.position.y;
		let looped = 0;
		if (curPos > roadSize) {
			looped = 1;
			curPos -= roadSize;
		} else if (curPos < 0) {
			looped = -1;
			curPos += roadSize;
		}
		let pos = curPos + roadSize/2;
		objs.container.position.z = this.rootRoad.model.position.z =  pos * Math.cos(this.roadAngle);
		objs.container.position.y = this.rootRoad.model.position.y = -pos * Math.sin(this.roadAngle);

		if (looped) {
			objs.container.children.forEach(i => {
				i.loops = (i.loops || 0) + 1;
				i.position.z += oldz - objs.container.position.z;
				i.position.y += oldy - objs.container.position.y;
			});
		}
	});

	// passenger
	const poseBase = 'passenger';
	const initialPose = 'walk';
	this.passenger = this.Model('passenger', `${poseBase}_${initialPose}_n`, { transparent: true, doubleSided: true });
	this.passengerLegs = this.Model('passenger', 'passenger_legs', { transparent: true, doubleSided: true });
	// fix alpha
	this.passenger.model.children.forEach(i => i.visible = false);
	this.passengerPlane = this.passenger.model.getChildByName('passenger_plane');
	this.passengerLegsPlane = this.passengerLegs.model.getChildByName('passenger_plane');
	this.passengerPlane.visible = true;
	this.passengerPlane.position.x -= 0.0001;
	this.passenger.model.parent.setChildIndex(this.passenger.model, this.passenger.model.parent.children.length-1);
	this.passengerLegs.model.children.forEach(i => i.visible = false);
	this.passengerLegs.model.getChildByName('passenger_plane').visible = true;
	this.passengerLegs.model.parent.setChildIndex(this.passengerLegs.model, this.passengerLegs.model.parent.children.length-1);

	const passengerMouthFront = this.passenger.model.getChildByName('mouth_forward');
	const passengerMouthBack = this.passenger.model.getChildByName('mouth_backward');
	this.scene.pointDialogue.position = passengerMouthFront.position;

	this.EnvModel = (...args) => {
		const m = this.Model(...args);
		objs.container.addChild(m.model);
		m.model.position.x -= objs.container.position.x;
		m.model.position.y -= objs.container.position.y;
		m.model.position.z -= objs.container.position.z;
		return m;
	};
	this.tex('mountainTexture').baseTexture.scaleMode = 1;
	this.Model('mountainShape2', 'mountainTexture');
	this.Model('mountainShape3', 'palette', {depth: 366});
	this.Model('mountainShape4', 'palette', {depth: 220});
	const clouds1 = this.Model('cloudShape1', 'white', { depth: 366 });
	const clouds2 = this.Model('cloudShape2', 'white', { depth: 256 });
	const clouds3 = this.Model('cloudShape3', 'white', { depth: 300 });
	const clouds4 = this.Model('cloudShape4', 'white', { depth: 300 });
	// move clouds
	clouds1.model.rotationQuaternion.setEulerAngles(this.roadAngle * 180 / Math.PI, 0, 0);
	this.Updater(() => {
		clouds1.model.getChildAt(0).rotationQuaternion.setEulerAngles(0, game.app.ticker.lastTime * 0.005, 0);
		clouds2.model.position.y = Math.sin(game.app.ticker.lastTime * 0.0005) + Math.sin(game.app.ticker.lastTime * 0.00023)*0.5;
		clouds3.model.position.y = Math.sin(game.app.ticker.lastTime * 0.0002) + Math.sin(game.app.ticker.lastTime * 0.00045)*0.5;
		clouds4.model.position.y = Math.sin(game.app.ticker.lastTime * 0.0002) + Math.sin(game.app.ticker.lastTime * 0.00055)*0.5;
	});

	// random props
	// const props = [
	// 	'roadsideTrash1',
	// 	'roadsideTrash1',
	// 	'roadsideTrash1',
	// 	'roadsideTrash2',
	// 	'roadsideTrash2',
	// 	'roadsideTrash2',
	// 	'pothole1',
	// 	'pothole1',
	// 	'cactus1',
	// 	'cactus1',
	// 	'cactus2',
	// 	'cactus2',
	// 	'cactus3',
	// 	'cactus3',
	// 	'cactus4',
	// 	'cactus4',
	// 	'cactus5',
	// 	'cactus5',
	// 	'cactus6',
	// 	'cactus6',
	// 	'cactus7',
	// 	'cactus7',
	// 	'cactus8',
	// 	'cactus8',
	// 	'longhornskull',
	// ];
	// let lastprop;
	// const rndprop = () => {
	// 	if (!lastprop || lastprop.model.destroyed) {
	// 		const prop = this.shuffle(props)[0];
	// 		lastprop = this.EnvModel(prop);
	// 	}
	// 	setTimeout(rndprop, Math.random()*25000+Math.random()*25000+5000);
	// };
	// rndprop();
	// let lastprop2;
	// const rndprop2 = () => {
	// 	if (!lastprop2 || lastprop2.model.destroyed) {
	// 		const prop = this.shuffle(props)[0];
	// 		lastprop2 = this.EnvModel(prop);
	// 	}
	// 	setTimeout(rndprop2, Math.random()*25000+Math.random()*25000+5000);
	// };
	// rndprop2();

	// const boulders = [
	// 	'boulder1',
	// 	'boulder2',
	// 	'boulder3',
	// 	'boulder4',
	// 	'boulder5',
	// 	'boulder6',
	// 	'boulder7',
	// 	'boulder8',
	// 	'boulder9',
	// 	'boulder10',
	// 	'boulder11',
	// 	'boulder12',
	// ];
	// const rndprop3 = () => {
	// 	const prop = this.shuffle(boulders)[0];
	// 	const model = this.EnvModel(prop);
	// 	model.model.position.y -= 1.36;
	// 	setTimeout(rndprop3, Math.random()*3000+Math.random()*1000+100);
	// };
	// rndprop3();

	// pose helper
	const poses = {
		':(': 'sad',
		':)': 'normal',
		'o_o': 'facing_you',
		'-_-': 'facing_away',
	};

	const terr = this.tex('error');
	let prev = '';
	this.setPose = (pose, state) => {
		this.pose = poses[pose] || pose;
		const frame = this.passenger.animator.frame;
		const offset = this.passenger.animator.offset;
		let t = [poseBase, this.pose, state].filter(i => i).join('_');
		if (t === prev) return;
		prev = t;
		if (this.tex(t) === terr) t = [poseBase, this.pose].filter(i => i).join('_');
		if (this.tex(t) === terr) t = [poseBase, initialPose, state].filter(i => i).join('_');
		if (this.tex(t) === terr) t = [poseBase, state].filter(i => i).join('_');
		if (this.tex(t) === terr) t = poseBase;
		this.passenger.setAnimation(t);
		this.passenger.animator.frame = frame;
		this.passenger.animator.offset = offset;
		this.passenger.animator.updateTexture();
		if (pose.includes('stand')) {
			this.passengerLegs.setAnimation('blank');
			this.passengerLegs.animator.updateTexture();
		} else {
			this.passengerLegs.setAnimation('passenger_legs');
			this.passengerLegs.animator.updateTexture();
		}
	};


	// blinking and lip flaps
	this.pose = initialPose;
	this.blinking = false;
	this.timeoutBlinking;
	this.scene.dialogue.scripts.push({
		gameObject: this.scene.dialogue,
		update: () => {
			if (!this.pose) return;
			if (!this.timeoutBlinking) {
				this.timeoutBlinking = setTimeout(() => {
					this.blinking = !this.blinking;
					this.timeoutBlinking = null;
				}, this.blinking ? 100 : 2000+Math.random()*4000);
			};

			const letter = this.scene.dialogue.strText[scene.dialogue.pos];
			const isLetter = letter && letter.replace(/[^\w]/, '');
			if (isLetter) {
				this.setPose(this.pose, 'o');
			} else if (this.blinking) {
				this.setPose(this.pose, 'b');
			} else {
				this.setPose(this.pose, 'n');
			}
		},
	});
	this.setPose(this.pose, 'n');

	// footsteps
	this.scene.dialogue.scripts.push({
		gameObject: this.scene.dialogue,
		update: () => {
			if (this.passengerLegs.animator.frameChanged && (this.passengerLegs.animator.frame === 1 || this.passengerLegs.animator.frame === 4)) {
				this.tweenAbort(this.steppingTween);
				this.steppingTween = this.tween(this, 'stepping', 0, 1300, 1);
				this.sfx('stepDefault', {
					rate: Math.random()*0.25+0.75,
					volume: Math.random()*0.25+0.75,
				});
				if (this.roadSpeed > 0) {
					const print = this.EnvModel('footprint', 'black', { depth: baseDepth });
					// offset left/right
					print.model.position.x += Math.sign(this.passengerLegs.animator.frame - 2) > 0 ? 0.2 : 0.05;
				} else {
					const print = this.EnvModel('footprint_backward', 'black', { depth: baseDepth });
					// offset left/right
					print.model.position.x += Math.sign(this.passengerLegs.animator.frame - 2) > 0 ? 0.35 : 0.2;
				}
			}
		},
	});

	// walk direction
	let baseScale = this.passengerPlane.scale.x;
	this.scene.dialogue.scripts.push({
		gameObject: this.scene.dialogue,
		update: () => {
			this.passengerLegsPlane.scale.x = this.passengerPlane.scale.x = baseScale * Math.sign(this.roadSpeed);
			this.scene.pointDialogue.position = Math.sign(this.roadSpeed) > 0 ? passengerMouthFront.position : passengerMouthBack.position;
		},
	});


	// add syntax sugar for poses like `:( - Blah blah`
	const check = /^(.*) - /;
	this.scene.dialogue.sayo = this.scene.dialogue.say;
	this.scene.dialogue.say = (text, actions) => {
		const match = check.exec(text);
		if (match) {
			this.setPose(match[1]);
			return this.scene.dialogue.sayo(text.substring(match[0].length), actions);
		} else {
			return this.scene.dialogue.sayo(text, actions);
		}
	};

	// 	this.music('bgm');

	// start
	this.started=true;
	this.goto('start2');
>>
<<endif>>

::close
this should never render

::debug menu
debug menu

[[passage select>passage select]]
[[close]]
[[get interaction region|console.log(this.scene.x, this.scene.y)]]
[[back|this.back()]]

::start2
<<do
	this.setPose('stand', 'n');
	this.goto('close');
	(async () => {
		this.scene.container3d.visible = true;
		this.scenarios = [].concat(
			...this.shuffle(Object.keys(this.passages).filter(i => i.startsWith('scenario-up-'))),
			'scenario-top',
			...this.shuffle(Object.keys(this.passages).filter(i => i.startsWith('scenario-down-'))),
			'scenario-end',
		);
		this.scenarios.reverse();

		// await this.delay(556*8);
		// const t = scene.strand.Text('TAXI');
		// game.app.stage.addChild(t.display.container);
		// t.text.style.fontSize = 50;
		// t.text.style.fill = 0x406885;
		// t.text.x = 30;
		// t.text.y = 30;

		// await this.delay(556*2);
		// t.text.text = 'TAXI QUEST';


		// await this.delay(556*2);
		// const t2 = scene.strand.Text('66');
		// game.app.stage.addChild(t2.display.container);
		// t2.text.style.fontSize = 240;
		// t2.text.style.fill = 0x406885;
		// t2.text.x = 30;
		// t2.text.y = 10;

		// await this.delay(556*6);
		// t.destroy();
		// t2.destroy();

		this.scrim(1);
		this.scrim(0, 1000);
		this.rootRoad.model.visible = false;
		this.bottom.model.visible = true;
		this.gotod('start3', 3000)
	})();
>>

::start3
stand - talking at the bottom
>
starting the trip
>
<<do
	this.goto('close');
	this.scrim(1, 1000);
	setTimeout(() => {
		this.scrim(0, 1000);
		this.rootRoad.model.visible = true;
		this.bottom.model.visible = false;
		this.setPose('walk', 'n');
		this.gotod('start4', 3000)
	}, 3000);
>>


::start4
intro walking up
[[>main]]

::main
<<do
	this.goto('close');
	this.gotod(this.scenarios.pop() || 'scenario-end', this.debug ? 2000 : (Math.random()*10+12)*1000);
>>









//  dP     dP  888888ba
//  88     88  88    `8b
//  88     88 a88aaaa8P'
//  88     88  88
//  Y8.   .8P  88
//  `Y88888P'  dP

::scenario-up-test1
test scenario walking up
[[>main]]




// d888888P  .88888.   888888ba
//    88    d8'   `8b  88    `8b
//    88    88     88 a88aaaa8P'
//    88    88     88  88
//    88    Y8.   .8P  88
//    dP     `8888P'   dP
::scenario-top
<<do
	this.goto('close');
	this.scrim(1, 1000);
	setTimeout(() => {
		this.scrim(0, 1000);
		this.rootRoad.model.visible = false;
		this.top.model.visible = true;
		this.setPose('stand', 'n');
		this.gotod('scenario-top2', 3000)
	}, 3000);
>>

::scenario-top2
stand - test mountain top
>
<<do
	this.goto('close');
	this.scrim(1, 1000);
	setTimeout(() => {
		this.scrim(0, 1000);
		this.rootRoad.model.visible = true;
		this.top.model.visible = false;
		this.roadSpeed *= -1;
		this.scene.x = -180;
		this.scene.y = 20;
		this.setPose('walk', 'n');
		this.gotod('scenario-top3', 3000)
	}, 3000);
>>

::scenario-top3
walk - walking back down
[[>main]]



// 888888ba   .88888.  dP   dP   dP 888888ba
// 88    `8b d8'   `8b 88   88   88 88    `8b
// 88     88 88     88 88  .8P  .8P 88     88
// 88     88 88     88 88  d8'  d8' 88     88
// 88    .8P Y8.   .8P 88.d8P8.d8P  88     88
// 8888888P   `8888P'  8888' Y88'   dP     dP

::scenario-down-test1
test scenario walking down
[[>main]]




//  88888888b 888888ba  888888ba
//  88        88    `8b 88    `8b
// a88aaaa    88     88 88     88
//  88        88     88 88     88
//  88        88     88 88    .8P
//  88888888P dP     dP 8888888P
::scenario-end
:) - Oh, is that a sign up ahead?
>
<<do
	this.scene.interactive = false;
	this.scrim(1, 4000);
>>
I think this is my exit.
>
<<do
	this.goto('close');
	this.gotod('scenario-end2', 5000);
>>

::scenario-end2
This is it, huh?
>
<<do this.sfx('door_open')>>
...
>
So, uh.
>
How much do I owe you?
[[ |((async () => {
		if (this.ended) return;
		this.ended = true;

		await this.delay(3000);
		this.sfx('door_close');
		this.goto('close');

		await this.delay(3000);
		const e = this.EnvModel('exitSign');
		e.model.rotationQuaternion.setEulerAngles(0, 180, 0);
		e.model.position.x -= 7;
		this.chimneys.model.rotationQuaternion.setEulerAngles(0, 180, 0);
		this.scene.interactive = true;
		this.scrim(0, 3000);
		this.passenger.model.visible = false;
		this.passengerProps.model.visible = false;
		this.aloneProps.model.visible = true;

		await this.delay(6000);
		const t = this.Text('The End');
		t.text.anchor.x = 1.0;
		t.text.anchor.y = 1.0;
		t.display.container.x = game.app.renderer.width - 30;
		t.display.container.y = game.app.renderer.height - 20;
		this.sfx('door_open', { rate: 2.0 });
		window.game.app.stage.addChild(t.display.container);
	})());
]]
